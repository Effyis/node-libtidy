"use strict";
/**
 * Generate TypeScript decl for options in node-libtidy
 *
 * @author Wang Guan <momocraft@gmail.com>
 *
 * vim: shiftwidth=2
 */
const fs = require("fs");
const path = require("path");
const dom = require("dts-dom");
const chai = require("chai");
const libtidy = require("../");
/**
 * Main entrypoint: generate and update ../src/index.d.ts
 */
function main() {
  const dts = path.join(__dirname, "..", "src", "options.d.ts");
  const content = generate();

  fs.writeFileSync(dts, content);
  console.log(`successfully generated ${dts}`);
  process.exit(0);
}

main();

/**
 * Create type for union of constants
 * @return dom.Type
 */
function createConstUnion(values) {
  const v = values.map(_ => typeof _ === "string" ? JSON.stringify(_) : _);
  const u = v.map(_ => dom.create.namedTypeReference(v));
  return dom.create.union(u);
}

/**
 * re-indent 4-spaced lines generated by dts-dom
 * @param lines lines to format
 */
function format(lines) {
  return lines
    .map(l => l.replace(/^\s+/, headSpaces => headSpaces.substring(0, headSpaces.length / 2)))
    .join("\n");
}

function uniq(items, eq) {
  const result = [];
  for (const i of items) {
    if (!result.some(v => eq ? eq(i, v) : i === v))
      result.push(i);
  }
  return result;
}

/**
 * Change "skip-nested" to "SkipNested"
 * @param optionName option name in '-' notation
 */
function camelCaseName(optionName) {
  return optionName
    .split('-')
    .map(upperFirst)
    .join('');
}

/**
 * Change "skip-nested" to "skip_nested"
 * @param optionName option name in '-' notation
 */
function underscoreName(optionName) {
  return optionName.replace(/-/g, '_');
}

function upperFirst(word) {
  return word.replace(/(^.)/, (m, $1) => $1.toUpperCase());
}

/**
 * Enumerate variants of option name
 *
 * @param {string} optionName
 * @returns {string[]} variants
 */
function enumerateNames(optionName) {
  const name1 = optionName;
  const name2 = underscoreName(optionName);
  const name3 = camelCaseName(optionName);
  return uniq([name1, name2, name3]);
}

/**
 *
 *
 * @param {libtidy.TidyOption} o the option
 * @returns {dom.Type} A union type that can be used to set/get the option
 */
function nameUnion(o) {
  const names = enumerateNames(o.name).map(n => JSON.stringify(n));
  const t = (names.length === 1) ?
    dom.create.namedTypeReference(names[0]) :
    dom.create.union(names.map(dom.create.namedTypeReference));
  return t;
}

/**
 * throw if our expectation of libtidy is incorrect
 * @param {libtidy.TidyDoc} d the TidyDoc to use
 * @param {libtidy.TidyOption} o the option to try
 */
function validateOption(d, o) {
  if (o.readOnly)
    return;

  if (o.type === 'integer' && o.pickList.length) {
    // integer and a non-empty picklist:
    // optGet() return normalized value
    o.pickList.forEach((value, i) => {
      chai.expect(d.optSet(o.name, i)).to.eq(undefined);
      chai.expect(d.optGet(o.name)).to.eq(value);
      chai.expect(d.optSet(o.name, value)).to.eq(undefined);
      chai.expect(d.optGet(o.name)).to.eq(value);
    });
  } else if (o.type === 'integer') {
  } else if (o.type === 'boolean') {
    chai.expect(typeof d.optGet(o)).eq("boolean");
    chai.expect(typeof d.optGet(o.name)).eq("boolean");
    chai.expect(typeof d.optGet(o.id)).eq("boolean");

    // optSet a boolean option returns undefined
    chai.expect(d.optSet(o, true)).eq(undefined);
    chai.expect(d.optSet(o, false)).eq(undefined);
  } else if (o.type === 'string') {
  } else
    throw new Error(`not implemented for option type '${o.type}'`);
}

function optGet(o) {
  const method = dom.create.method("optGet", [dom.create.parameter("key", nameUnion(o))],
    valueType(o, "get"));

  const jsdoc = [`${o.category} / ${o.name} (${o.type})`];
  method.jsDocComment = jsdoc.join("\n");

  return method;
}

function optSet(o) {
  const method = dom.create.method("optSet", [dom.create.parameter("key", nameUnion(o)), dom.create.parameter("value", valueType(o, "set"))],
    dom.create.namedTypeReference("void")
  );
  return method;
}

/**
 * the type for available option values
 * @param {libtidy.TidyOption} o
 * @param {"set"|"get"} a setter accepts a wider range of values
 */
function valueType(o, use) {
  if (o.type === "integer") {
    if (!o.pickList.length) {
      return dom.create.namedTypeReference("number");
    }
    const optionValues = o.pickList.map(v => JSON.stringify(v));
    if (use === 'set') {
      // when setting: number can be used as well
      for (let i = o.pickList.length; --i >= 0;) {
        optionValues.splice(i + 1, 0, [i]);
      }
    }
    const u = optionValues.map(dom.create.namedTypeReference);
    return dom.create.union(u);
  } else if (o.type === "string") {
    if (!o.pickList.length) {
      return dom.create.namedTypeReference("string");
    }
    return dom.create.union(o.pickList.map(
      v => dom.create.namedTypeReference(JSON.stringify(v))));
  } else if (o.type === "boolean") {
    return dom.create.namedTypeReference("boolean");
  }
  throw new Error(`not implemented for option type '${o.type}'`);
}

/**
 *
 *
 * @returns {string} A long string of `namespace Generated ...`
 */
function generate() {
  const doc = new libtidy.TidyDoc();
  const options = doc.getOptionList();
  const toplevel = dom.create.namespace("Generated");
  toplevel.flags = dom.DeclarationFlags.Export;
  toplevel.jsDocComment = `
Type for libtidy options
@generated with /util/gen-typescript-decl.ts
    `.trim();
  // type of TidyDoc.options
  const optionDict = dom.create.interface("OptionDict");
  optionDict.jsDocComment = `
NOTE: some values will not be returned from getter.
TypeScript does not allow us to distinguish setter and getter in declaration.
`.trim();
  // optGet / optSet overloads in TidyDoc
  const optAccessors = dom.create.interface('TidyDocOption');
  for (const o of options) {
    validateOption(doc, o);
  }
  for (const o of options) {
    optAccessors.members.push(optGet(o));
    optAccessors.members.push(optSet(o));
    optionDict.members.push(dom.create.property(underscoreName(o.name), valueType(o, "set"), dom.DeclarationFlags.Optional));
  }
  toplevel.members.push(optAccessors);
  toplevel.members.push(optionDict);
  const lines = dom.emit(toplevel).split(/\r\n|\n/);
  return format(lines);
}